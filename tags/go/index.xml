<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Leo Ryu&#39;s Blog</title>
    <link>https://leoryu.github.io/tags/go/</link>
    <description>Recent content in go on Leo Ryu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Sep 2019 21:55:00 +0800</lastBuildDate>
    
	<atom:link href="https://leoryu.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Go的算法实现]合并两个排序的链表</title>
      <link>https://leoryu.github.io/sword017-merge-2-sorted-list/</link>
      <pubDate>Sun, 01 Sep 2019 21:55:00 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword017-merge-2-sorted-list/</guid>
      <description>&lt;p&gt;剑指Offer中问题17的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]反转列表</title>
      <link>https://leoryu.github.io/sword016-reverse-node-list/</link>
      <pubDate>Sat, 31 Aug 2019 22:47:00 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword016-reverse-node-list/</guid>
      <description>&lt;p&gt;剑指Offer中问题16的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]链表中倒数第k个结点</title>
      <link>https://leoryu.github.io/sword015-cont-donw-to-k-node/</link>
      <pubDate>Fri, 30 Aug 2019 22:00:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword015-cont-donw-to-k-node/</guid>
      <description>&lt;p&gt;剑指Offer中问题15的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]调整数组顺序使奇数位于偶数前面</title>
      <link>https://leoryu.github.io/sword014-adjust-order-of-odd-and-even/</link>
      <pubDate>Fri, 02 Aug 2019 23:30:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword014-adjust-order-of-odd-and-even/</guid>
      <description>&lt;p&gt;剑指Offer中问题14的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]打印1到最大的N位数</title>
      <link>https://leoryu.github.io/sword012-print-one-to-max-number-of-dig-n/</link>
      <pubDate>Thu, 01 Aug 2019 21:30:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword012-print-one-to-max-number-of-dig-n/</guid>
      <description>&lt;p&gt;剑指Offer中问题12的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]数值的整数次方</title>
      <link>https://leoryu.github.io/sword011-float-to-the-power-of-int/</link>
      <pubDate>Fri, 26 Jul 2019 22:40:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword011-float-to-the-power-of-int/</guid>
      <description>&lt;p&gt;剑指Offer中问题11的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>高并发场景Golang进行转发和代理时的注意事项</title>
      <link>https://leoryu.github.io/how-to-use-http-client/</link>
      <pubDate>Wed, 24 Jul 2019 23:40:24 +0800</pubDate>
      
      <guid>https://leoryu.github.io/how-to-use-http-client/</guid>
      <description>&lt;p&gt;在以RESTful API通信为基础的微服务场景下，Golang自带的HTTP客户端和反向代理在调用外部服务时非常好用。但是如果使用不当，程序经常会出现一些奇怪的错误，并且这些错误只会在高并发的场景下才会显露出来，在程序进入实际生产环境前很难被发现。&lt;/p&gt;
&lt;p&gt;笔者将在本文中将根据工作中遇到的一些问题，介绍一下高并发场景下Golang进行转发和代理时需要注意的事项。由于代理的本质和HTTP Client在Golang中是一样的，了解其一便可，所以本文将只针对HTTP Client进行讨论。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]二进制中1的个数</title>
      <link>https://leoryu.github.io/sword010-one-in-binary/</link>
      <pubDate>Wed, 17 Jul 2019 21:40:24 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword010-one-in-binary/</guid>
      <description>&lt;p&gt;剑指Offer中问题10的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]斐波那契数列</title>
      <link>https://leoryu.github.io/sword009-fibonacci-number/</link>
      <pubDate>Tue, 16 Jul 2019 21:40:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword009-fibonacci-number/</guid>
      <description>&lt;p&gt;剑指Offer中问题9的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]旋转数组的最小数字</title>
      <link>https://leoryu.github.io/sword008-min-in-rotate-array/</link>
      <pubDate>Mon, 08 Jul 2019 22:50:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword008-min-in-rotate-array/</guid>
      <description>&lt;p&gt;剑指Offer中问题8的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]用两个栈实现队列</title>
      <link>https://leoryu.github.io/sword007-build-queue-with-stacks/</link>
      <pubDate>Tue, 28 May 2019 22:50:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword007-build-queue-with-stacks/</guid>
      <description>&lt;p&gt;剑指Offer中问题7的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]重建二叉树</title>
      <link>https://leoryu.github.io/sword006-rebuild-binary-tree/</link>
      <pubDate>Mon, 27 May 2019 22:28:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword006-rebuild-binary-tree/</guid>
      <description>&lt;p&gt;剑指Offer中问题6的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]从尾到头打印链表</title>
      <link>https://leoryu.github.io/sword005-print-from-tail-to-head/</link>
      <pubDate>Sun, 12 May 2019 22:18:39 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword005-print-from-tail-to-head/</guid>
      <description>&lt;p&gt;剑指Offer中问题5的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]替换空格</title>
      <link>https://leoryu.github.io/sword004-replace-space/</link>
      <pubDate>Sat, 27 Apr 2019 22:03:01 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword004-replace-space/</guid>
      <description>&lt;p&gt;剑指Offer中问题4的go实现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]二维数组中的查找</title>
      <link>https://leoryu.github.io/sword003-find-in-2darray/</link>
      <pubDate>Tue, 16 Apr 2019 19:45:48 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword003-find-in-2darray/</guid>
      <description>&lt;p&gt;剑指Offer中问题3的go实现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>协程代替进程：单容器Go语言应用提供多服务的解决方案</title>
      <link>https://leoryu.github.io/move-thread-to-coroutine/</link>
      <pubDate>Wed, 20 Feb 2019 21:27:46 +0800</pubDate>
      
      <guid>https://leoryu.github.io/move-thread-to-coroutine/</guid>
      <description>1. Docker容器内运行多个服务 Docker推荐开发者每个容器内运行一个服务/守护进程，以区分关注的区域。因此，并没有针对容器内运行多进程的场景做过多的设计。例如生命周期上，Docker只关注容器内的1号进程，1号进程以外的生命周期需要开发者去维护。
但在实际开发中，因为各种原因开发者们确实会遇到在单个容器内运行多服务的开发场景。目前解决这一问题的通用解决方案大致分为两种：
 写shell脚本运行多进程 使用supervisor、foreman、goreman等多进程管理程序  但是这些通用解决方案都有一些缺陷，如依赖过多、占据容器内1号进程难以“优雅关闭”、造成资源浪费等。
2. 巧用Go语言的协程 Go语言有一个先天优势：可以用成本（开发成本、计算成本）极小的协程来代替线程。
而笔者在学习Gin框架时发现，Go的协程也可以代替进程，从而实现“单进程多服务”的效果。
而如果实现单进程多服务，则可以在几乎没有任何副作用的前提下实现单容器内运行多个服务。
该方案的Gin框架实现的代码可以参考multiple-service，这里笔者以日常使用的Echo框架实现一个多web服务，代码如下：
package main import ( &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;time&amp;quot; &amp;quot;golang.org/x/sync/errgroup&amp;quot; &amp;quot;github.com/labstack/echo&amp;quot; ) var g errgroup.Group func main() { server1 := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: router1(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } server2 := &amp;amp;http.Server{ Addr: &amp;quot;:8081&amp;quot;, Handler: router2(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } g.Go(func() error { return server1.ListenAndServe() }) g.Go(func() error { return server2.</description>
    </item>
    
    <item>
      <title>压缩界“黑科技”UPX：把可执行文件压缩至原有的30%</title>
      <link>https://leoryu.github.io/introduction-of-upx/</link>
      <pubDate>Sat, 19 Jan 2019 19:40:24 +0800</pubDate>
      
      <guid>https://leoryu.github.io/introduction-of-upx/</guid>
      <description>&lt;p&gt;笔者在这里介绍一个工具，UPX，该工具可以在不影响程序运行时功能和性能的前提下，将可执行文件压缩至原体积的30%-50%。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>