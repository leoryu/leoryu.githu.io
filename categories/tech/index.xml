<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on Leo Ryu&#39;s Blog</title>
    <link>https://leoryu.github.io/categories/tech/</link>
    <description>Recent content in Tech on Leo Ryu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 May 2020 22:55:00 +0800</lastBuildDate>
    
	<atom:link href="https://leoryu.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kubernetes中的认证</title>
      <link>https://leoryu.github.io/kubernetes-authentication/</link>
      <pubDate>Wed, 27 May 2020 22:55:00 +0800</pubDate>
      
      <guid>https://leoryu.github.io/kubernetes-authentication/</guid>
      <description>&lt;p&gt;来源：https://jimmysong.io/kubernetes-handbook/guide/authentication.html&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/kubernetes-single-sign-one-less-identity/&#34;&gt;https://thenewstack.io/kubernetes-single-sign-one-less-identity/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 集群中包含两类用户：一类是由 Kubernetes 管理的 service account，另一类是普通用户。&lt;/p&gt;
&lt;p&gt;普通用户被假定为由外部独立服务管理。管理员分发私钥，用户存储（如 Keystone 或 Google 帐户），甚至包含用户名和密码列表的文件。在这方面，Kubernetes 没有代表普通用户帐户的对象。无法通过 API 调用的方式向集群中添加普通用户。&lt;/p&gt;
&lt;p&gt;相对的，service account 是由 Kubernetes API 管理的帐户。它们都绑定到了特定的 namespace，并由 API server 自动创建，或者通过 API 调用手动创建。Service account 关联了一套凭证，存储在 Secret，这些凭证同时被挂载到 pod 中，从而允许 pod 与 kubernetes API 之间的调用。&lt;/p&gt;
&lt;p&gt;API 请求被绑定到普通用户或 serivce account 上，或者作为匿名请求对待。这意味着集群内部或外部的每个进程，无论从在工作站上输入 kubectl 的人类用户到节点上的 kubelet，到控制平面的成员，都必须在向 API Server 发出请求时进行身份验证，或者被视为匿名用户。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>服务端推送技术</title>
      <link>https://leoryu.github.io/server-push/</link>
      <pubDate>Tue, 26 May 2020 21:55:00 +0800</pubDate>
      
      <guid>https://leoryu.github.io/server-push/</guid>
      <description>&lt;p&gt;在现实世界中，我们可能会服务端在发生数据变化后能够以较低的延迟通知到客户端，这是我们就需要一个服务端推送方案。本文将介绍一些服务器端推送方案的思路，并逐一分析其优缺点。这些方案包含短轮询、长轮询、WebSocket、SSE和注册回调。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]合并两个排序的链表</title>
      <link>https://leoryu.github.io/sword017-merge-2-sorted-list/</link>
      <pubDate>Sun, 01 Sep 2019 21:55:00 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword017-merge-2-sorted-list/</guid>
      <description>&lt;p&gt;剑指Offer中问题17的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]反转列表</title>
      <link>https://leoryu.github.io/sword016-reverse-node-list/</link>
      <pubDate>Sat, 31 Aug 2019 22:47:00 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword016-reverse-node-list/</guid>
      <description>&lt;p&gt;剑指Offer中问题16的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]链表中倒数第k个结点</title>
      <link>https://leoryu.github.io/sword015-cont-donw-to-k-node/</link>
      <pubDate>Fri, 30 Aug 2019 22:00:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword015-cont-donw-to-k-node/</guid>
      <description>&lt;p&gt;剑指Offer中问题15的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]调整数组顺序使奇数位于偶数前面</title>
      <link>https://leoryu.github.io/sword014-adjust-order-of-odd-and-even/</link>
      <pubDate>Fri, 02 Aug 2019 23:30:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword014-adjust-order-of-odd-and-even/</guid>
      <description>&lt;p&gt;剑指Offer中问题14的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]打印1到最大的N位数</title>
      <link>https://leoryu.github.io/sword012-print-one-to-max-number-of-dig-n/</link>
      <pubDate>Thu, 01 Aug 2019 21:30:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword012-print-one-to-max-number-of-dig-n/</guid>
      <description>&lt;p&gt;剑指Offer中问题12的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]数值的整数次方</title>
      <link>https://leoryu.github.io/sword011-float-to-the-power-of-int/</link>
      <pubDate>Fri, 26 Jul 2019 22:40:34 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword011-float-to-the-power-of-int/</guid>
      <description>&lt;p&gt;剑指Offer中问题11的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>高并发场景Golang进行转发和代理时的注意事项</title>
      <link>https://leoryu.github.io/how-to-use-http-client/</link>
      <pubDate>Wed, 24 Jul 2019 23:40:24 +0800</pubDate>
      
      <guid>https://leoryu.github.io/how-to-use-http-client/</guid>
      <description>&lt;p&gt;在以RESTful API通信为基础的微服务场景下，Golang自带的HTTP客户端和反向代理在调用外部服务时非常好用。但是如果使用不当，程序经常会出现一些奇怪的错误，并且这些错误只会在高并发的场景下才会显露出来，在程序进入实际生产环境前很难被发现。&lt;/p&gt;
&lt;p&gt;笔者将在本文中将根据工作中遇到的一些问题，介绍一下高并发场景下Golang进行转发和代理时需要注意的事项。由于代理的本质和HTTP Client在Golang中是一样的，了解其一便可，所以本文将只针对HTTP Client进行讨论。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]二进制中1的个数</title>
      <link>https://leoryu.github.io/sword010-one-in-binary/</link>
      <pubDate>Wed, 17 Jul 2019 21:40:24 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword010-one-in-binary/</guid>
      <description>&lt;p&gt;剑指Offer中问题10的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]斐波那契数列</title>
      <link>https://leoryu.github.io/sword009-fibonacci-number/</link>
      <pubDate>Tue, 16 Jul 2019 21:40:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword009-fibonacci-number/</guid>
      <description>&lt;p&gt;剑指Offer中问题9的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]旋转数组的最小数字</title>
      <link>https://leoryu.github.io/sword008-min-in-rotate-array/</link>
      <pubDate>Mon, 08 Jul 2019 22:50:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword008-min-in-rotate-array/</guid>
      <description>&lt;p&gt;剑指Offer中问题8的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes in Docker</title>
      <link>https://leoryu.github.io/introduction-of-kind/</link>
      <pubDate>Sun, 23 Jun 2019 20:26:32 +0800</pubDate>
      
      <guid>https://leoryu.github.io/introduction-of-kind/</guid>
      <description>&lt;p&gt;Installing Kubernetes locally is an annoying task. Without multiple bare machines, you need some extra storage and memory for VMs. Besides, you have to spend time on installation and dependency problems.If you want a Kubernetes cluster just for Dev/Test, it&amp;rsquo;s a nightmare.&lt;/p&gt;
&lt;p&gt;So here is a problem with Kubernetes, the Standard Kubernetes is great for production, but not suitable for building &amp;ldquo;temporarily&amp;rdquo;. In order to find a solution, this paper will introduce a project, kind, which makes it possible to run Kubernetes cluster in Docker.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker &#43; VSCode &#43; Windows搭建舒适开发环境</title>
      <link>https://leoryu.github.io/dev-with-docker/</link>
      <pubDate>Thu, 13 Jun 2019 23:07:55 +0800</pubDate>
      
      <guid>https://leoryu.github.io/dev-with-docker/</guid>
      <description>&lt;p&gt;最近VSCode的稳定版本已经开始支持Remote Development，这让笔者看到了远程开发更多的可能性。Linux的图形界面一直让人不是很满意（等待Wayland时代的到来），RD的出现让笔者对使用Windows界面在远端Linux环境开发产生了兴趣。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]用两个栈实现队列</title>
      <link>https://leoryu.github.io/sword007-build-queue-with-stacks/</link>
      <pubDate>Tue, 28 May 2019 22:50:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword007-build-queue-with-stacks/</guid>
      <description>&lt;p&gt;剑指Offer中问题7的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]重建二叉树</title>
      <link>https://leoryu.github.io/sword006-rebuild-binary-tree/</link>
      <pubDate>Mon, 27 May 2019 22:28:04 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword006-rebuild-binary-tree/</guid>
      <description>&lt;p&gt;剑指Offer中问题6的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]从尾到头打印链表</title>
      <link>https://leoryu.github.io/sword005-print-from-tail-to-head/</link>
      <pubDate>Sun, 12 May 2019 22:18:39 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword005-print-from-tail-to-head/</guid>
      <description>&lt;p&gt;剑指Offer中问题5的go实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]替换空格</title>
      <link>https://leoryu.github.io/sword004-replace-space/</link>
      <pubDate>Sat, 27 Apr 2019 22:03:01 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword004-replace-space/</guid>
      <description>&lt;p&gt;剑指Offer中问题4的go实现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go的算法实现]二维数组中的查找</title>
      <link>https://leoryu.github.io/sword003-find-in-2darray/</link>
      <pubDate>Tue, 16 Apr 2019 19:45:48 +0800</pubDate>
      
      <guid>https://leoryu.github.io/sword003-find-in-2darray/</guid>
      <description>&lt;p&gt;剑指Offer中问题3的go实现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker镜像的无中生有：使用scratch制作自定义最小镜像</title>
      <link>https://leoryu.github.io/build-docker-image-from-scratch/</link>
      <pubDate>Tue, 19 Mar 2019 20:53:06 +0800</pubDate>
      
      <guid>https://leoryu.github.io/build-docker-image-from-scratch/</guid>
      <description>&lt;p&gt;针对如何制作尽量小的镜像问题，笔者在这里介绍一种用”空镜像“制作自定义最小镜像的方案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>协程代替进程：单容器Go语言应用提供多服务的解决方案</title>
      <link>https://leoryu.github.io/move-thread-to-coroutine/</link>
      <pubDate>Wed, 20 Feb 2019 21:27:46 +0800</pubDate>
      
      <guid>https://leoryu.github.io/move-thread-to-coroutine/</guid>
      <description>1. Docker容器内运行多个服务 Docker推荐开发者每个容器内运行一个服务/守护进程，以区分关注的区域。因此，并没有针对容器内运行多进程的场景做过多的设计。例如生命周期上，Docker只关注容器内的1号进程，1号进程以外的生命周期需要开发者去维护。
但在实际开发中，因为各种原因开发者们确实会遇到在单个容器内运行多服务的开发场景。目前解决这一问题的通用解决方案大致分为两种：
 写shell脚本运行多进程 使用supervisor、foreman、goreman等多进程管理程序  但是这些通用解决方案都有一些缺陷，如依赖过多、占据容器内1号进程难以“优雅关闭”、造成资源浪费等。
2. 巧用Go语言的协程 Go语言有一个先天优势：可以用成本（开发成本、计算成本）极小的协程来代替线程。
而笔者在学习Gin框架时发现，Go的协程也可以代替进程，从而实现“单进程多服务”的效果。
而如果实现单进程多服务，则可以在几乎没有任何副作用的前提下实现单容器内运行多个服务。
该方案的Gin框架实现的代码可以参考multiple-service，这里笔者以日常使用的Echo框架实现一个多web服务，代码如下：
package main import ( &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;time&amp;quot; &amp;quot;golang.org/x/sync/errgroup&amp;quot; &amp;quot;github.com/labstack/echo&amp;quot; ) var g errgroup.Group func main() { server1 := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: router1(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } server2 := &amp;amp;http.Server{ Addr: &amp;quot;:8081&amp;quot;, Handler: router2(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } g.Go(func() error { return server1.ListenAndServe() }) g.Go(func() error { return server2.</description>
    </item>
    
    <item>
      <title>压缩界“黑科技”UPX：把可执行文件压缩至原有的30%</title>
      <link>https://leoryu.github.io/introduction-of-upx/</link>
      <pubDate>Sat, 19 Jan 2019 19:40:24 +0800</pubDate>
      
      <guid>https://leoryu.github.io/introduction-of-upx/</guid>
      <description>&lt;p&gt;笔者在这里介绍一个工具，UPX，该工具可以在不影响程序运行时功能和性能的前提下，将可执行文件压缩至原体积的30%-50%。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>